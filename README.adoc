:linkcss:
:stylesdir: css
:stylesheet: mystyle.css
:twoinches: width='360'
:full-width: width='100%'
:three-quarters-width: width='75%'
:two-thirds-width: width='66%'
:half-width: width='50%'  
:half-size:
:one-thirds-width: width='33%'
:one-quarters-width: width='25%'
:thumbnail: width='60'
:imagesdir: images
:sourcesdir: codes
:icons: font
:hide-uri-scheme!:
:figure-caption: 図
:example-caption: リスト
:table-caption: 表
:appendix-caption: 付録
:xrefstyle: short
:section-refsig:
:chapter-refsig:

= 構造のモデル図とコードの対応づけ

NOTE: この演習は、個人で実施します。


== 【準備】

.外部設計の準備
. 実機（EV3）とhakoniwaの開発環境が利用な可能なこと。
. Astah*が利用可能なこと。
. 新規ブロジェクトを作成して `model_to_code.asta` として `models` ディレクトリに保存します。
. GoogleDriveのSamplesフォルダから `samples01.tar.gz` を取得して、 `codes` ディレクトリに保存します。
. `samples01.tar.gz` を展開します。


== 【演習】モデル図と対応づいていないコード


[[sample01_app_png]]
.sample01のアクティビティ図
image::pic1.png[{one-quarters-width}]

[[sample01_app_c]]
.`sample01/app.c`
[example]
--
[source,ruby,linenums]
----
include::{souece}sample01/app.c
----
--

NOTE: このソースは、GitHubやプレビューでは見えません。Asciidoctor でHTMLに変換して確認してください。保存先は、`README.adoc` を同じ場所でよいです。


<<sample01_app_c>> が <<sample01_app_png>> の実装出会った場合、このコードの問題点を考えてみましょう。

.このコードの問題点を下記に箇条書きにしてください。

[[codes_issues]]
.コードの問題点
. 問題点を書く。
. 問題点を書く。

NOTE: 書いたらコミットします。

[[pic2_png]]
.ステートマシン図の振舞いが仕様と合っていない例
image::pi2.png[{one-quarters-width}]

[[pic2_spec_list]]
.動作の仕様
. 荷物が載ったら前進する
. 壁にぶつかったら止まる
. 荷物が降ろされたら後退する
. 2秒経ったら止まる
. 上記を繰り返す

<<pic2_png>> と <<pic2_spec_list>>  の対応に関する問題点を考えていましょう。

ステートマシン図と動作仕様の間の問題点を下記に箇条書きにしてください。

[[stm_issues]]
.ステートマシン図の問題点
. 問題点を書く。
. 問題点を書く。

NOTE: 書いたらコミットします。

== 【演習】コードの現状をクラス図で表す

<<sample01_app_c>> をそのままクラス図で表してみましょう。

.`sample01` のクラス図を作成する
. `model_to_code.asta` を開き、クラス図を追加します。
. クラス図の名前を「sample01のクラス図」とします。
. sample01のままのクラス図を描きます。

作成したクラス図を `sample01_class_01.png` として `images` ディレクトリに保存します。

.`sample01` のクラス図
image::sample01_class_01.png[{full-width}]


NOTE: ここでコミットしておきます。


== 【演習】コードを見直す

<<stm_issues>> 、 <<codes_issues>> について対処した場合はどのようなコードになるでしょう。

.`sample01` のコードを見直す
. `codes` ディレクトリの `sample01` を複製して、 `sample01-01` を作ります。
. `sample01-01/app.c` を編集して、問題に対処したコードに書き直します。
** 編集したコードが <<sample01_01_app_c>> になります。

[[sample01_01_app_c]]
.`sample01-01/app.c`
[example]
--
[source,ruby,linenums]
----
include::{souece}sample01-01/app.c
----
--

NOTE: ここでコミットしておきます。

== 【演習】見直したコードに合うクラス図を作る

`sample01` のクラス図を作ったときと同じように、 `sample01-01` のクラス図を作りましょう。

[TIP]
--
この演習では理解のために、コードを直してからモデルを直しています。
これで変換方式が決まれば、その方式に合わせて、モデルからコードに変換できるようになるわけです。
--

<<sample01_01_app_c>> をそのままクラス図で表してみましょう。

.`sample01-01` のクラス図を作成する
. `model_to_code.asta` を開き、クラス図を追加します。
. クラス図の名前を「sample01-01のクラス図」とします。
. sample01のままのクラス図を描きます。

作成したクラス図を `sample01_01_class_01.png` として `images` ディレクトリに保存します。

[[sample01_01_class_01_png]]
.`sample01-01` のクラス図
image::sample01_01_class_01.png[{full-width}]


NOTE: ここでコミットしておきます。


この検討の結果、階層化アーキテクチャがみいだせました（ <<layered_arch_01>> ）。

[[layered_arch_01]]
.階層化アーキテクチャがみいだせた
image::layered_arch.png[{three-quarters-width}]


== 【演習】クラス図にパッケージを追加しよう

階層化アーキテクチャが見いだせたので、 `sample01-01` も階層に合うよう編集しましょう。

<<sample01_01_class_01_png>> を見直して、パッケージを追加します。

.`sample01-01` にパッケージにパッケージを追加する
. 「sample01-01のクラス図」の並びに「パッケージ」を追加します。
. 追加したパッケージの名前に「app」とつけます（アプリケーションドメインの意味）。
. アプリケーションドメインに含まれるクラスを、このパッケージに移動します。
. 同様にして「unit」パッケージを追加して、ロボットのユニットのクラスを移動します。
. 同様にして「ev3rt」パッケージを追加して、EV3RTのモーターやセンサー、OSのAPIのクラスを移動します。
. それぞれのクラスを右クリックして、名前の表示/非表示から「名前空間」を表示するよう設定します。
** `porter` が `app::porter` のようにパッケージ名がついた表示に変わります。


作成したクラス図を `sample01_01_class_02.png` として `images` ディレクトリに保存します。

.`sample01-01` にパッケージじを追加したクラス図
image::sample01_01_class_02.png[{full-width}]

NOTE: ここでコミットしておきます。


