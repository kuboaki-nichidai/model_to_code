:Linkcss:
:stylesdir: css
:stylesheet: mystyle.css
:twoinches: width='360'
:full-width: width='100%'
:three-quarters-width: width='75%'
:two-thirds-width: width='66%'
:half-width: width='50%'
:half-size:
:one-thirds-width: width='33%'
:one-quarters-width: width='25%'
:thumbnail: width='60'
:imagesdir: images
:sourcesdir: codes
:icons: font
:hide-uri-scheme!:
:figure-caption: 図
:example-caption: リスト
:table-caption: 表
:appendix-caption: 付録
:xrefstyle: short
:section-refsig:
:chapter-refsig:

= モデル図とコードの対応づけ

IMPORTANT: この演習は、個人で実施します。

== モデル図とコードの対応について考える


=== 【準備】

.外部設計の準備
. 実機（EV3）とhakoniwaの開発環境が利用な可能なこと。
. Astah*が利用可能なこと。
. 新規ブロジェクトを作成して `model_to_code.asta` として `models` ディレクトリに保存します。
. GoogleDriveの共有フォルダのSamplesフォルダから `samples01.tar.gz` を取得して、 `codes` ディレクトリに保存します。
** 実際に動作させるときに使う hakoniwa や実機用の環境と異なる場所なのに注意します。
. `samples01.tar.gz` を展開します。
** 展開した結果、ファイルの場所は `model_to_code＞codes＞sample01＞app.c` のようになるでしょう。


=== 【演習】モデル図と対応づいていないコードを調べる


[[sample01_app_png]]
.sample01のアクティビティ図
image::pic1.png[{one-quarters-width}]

[[sample01_app_c]]
.`sample01/app.c`
[example]
--
[source,c,linenums]
----
include::{sourcesdir}/sample01/app.c[]
----
--

[NOTE]
--
このソースは、GitHubやプレビューでは見えないことがあります。
そのときは、Asciidoctor でHTMLに変換して確認してください。
--

<<sample01_app_c>> が <<sample01_app_png>> の実装出会った場合、このコードの問題点を考えてみましょう。

.このコードの問題点を下記に箇条書きにしてください。

[[codes_issues]]
.コードの問題点
. 問題点を書く。
. 問題点を書く。

NOTE: 書いたらコミットします。

[[pic2_png]]
.ステートマシン図の振舞いが仕様と合っていない例
image::pi2.png[{one-quarters-width}]

[[pic2_spec_list]]
.動作の仕様
. 荷物が載ったら前進する
. 壁にぶつかったら止まる
. 荷物が降ろされたら後退する
. 2秒経ったら止まる
. 上記を繰り返す

<<pic2_png>> と <<pic2_spec_list>>  の対応に関する問題点を考えていましょう。

ステートマシン図と動作仕様の間の問題点を下記に箇条書きにしてください。

[[stm_issues]]
.ステートマシン図の問題点
. 問題点を書く。
. 問題点を書く。

NOTE: 書いたらコミットします。

== 構造のモデル図とコードの対応づけ

=== 【演習】コードの現状をクラス図で表す

<<sample01_app_c>> をそのままクラス図で表してみましょう。

.`sample01` のクラス図を作成する
. `model_to_code.asta` を開き、クラス図を追加します。
. クラス図の名前を「sample01のクラス図」とします。
. sample01のままのクラス図を描きます。

作成したクラス図を `sample01_class_01.png` として `images` ディレクトリに保存します。

.`sample01` のクラス図
image::sample01_class_01.png[{full-width}]


NOTE: ここでコミットしておきます。


=== 【演習】コードを見直す

<<stm_issues>> 、 <<codes_issues>> について対処した場合はどのようなコードになるか見直してみてください。

.`sample01` のコードを見直す
. `codes` ディレクトリの `sample01` を複製して、 `sample01-01` を作ります。
. `sample01-01/app.c` を編集して、問題に対処したコードに書き直します。
** 編集したコードが <<sample01_01_app_c>> に表示されます。
** 表示できないときは `Unresolved directive in README.adoc - include::codes/sample01-01/app.c[]` となっているでしょう。

[[sample01_01_app_c]]
.`sample01-01/app.c`
[example]
--
[source,c,linenums]
----
include::{sourcesdir}/sample01-01/app.c[]
----
--


NOTE: ここでコミットしておきます。

=== 【演習】見直したコードに合うクラス図を作成する

`sample01` のクラス図を作ったときと同じように、 `sample01-01` のクラス図を作りましょう。

[TIP]
--
この演習では理解のために、コードを直してからモデルを直しています。
これで変換方式が決まれば、その方式に合わせて、モデルからコードに変換できるようになるわけです。
--

<<sample01_01_app_c>> をそのままクラス図で表してみましょう。

.`sample01-01` のクラス図を作成する
. `model_to_code.asta` を開き、クラス図を追加します。
. クラス図の名前を「sample01-01のクラス図」とします。
. sample01のままのクラス図を描きます。

作成したクラス図を `sample01_01_class_01.png` として `images` ディレクトリに保存します。

[[sample01_01_class_01_png]]
.`sample01-01` のクラス図
image::sample01_01_class_01.png[{full-width}]


NOTE: ここでコミットしておきます。

見直したコードやクラス図には、 `Porter` クラス、 `Driver` クラス、 `Bumper` クラスなどが追加できました。
最初にわからないといっていたことがらが、見えるかたちになったでしょうか。

この検討の結果、階層化アーキテクチャがみいだせました（ <<layered_arch_01>> ）。

[[layered_arch_01]]
.階層化アーキテクチャがみいだせた
image::layered_arch.png[{three-quarters-width}]


=== 【演習】クラス図にパッケージを追加しよう

階層化アーキテクチャが見いだせたので、 `sample01-01` も階層に合うよう編集しましょう。

<<sample01_01_class_01_png>> を見直して、パッケージを追加します。

.`sample01-01` にパッケージにパッケージを追加する
. 「sample01-01のクラス図」の並びに「パッケージ」を追加します。
. 追加したパッケージの名前に「app」とつけます（アプリケーションドメインの意味）。
. アプリケーションドメインに含まれるクラスを、このパッケージに移動します。
. 同様にして「unit」パッケージを追加して、ロボットのユニットのクラスを移動します。
. 同様にして「ev3rt」パッケージを追加して、EV3RTのモーターやセンサー、OSのAPIのクラスを移動します。
. それぞれのクラスを右クリックして、名前の表示/非表示から「名前空間」を表示するよう設定します。
** `porter` が `app::porter` のようにパッケージ名がついた表示に変わります。


作成したクラス図を `sample01_01_class_02.png` として `images` ディレクトリに保存します。

[[sample01_01_class_02_png]]
.`sample01-01` にパッケージじを追加したクラス図
image::sample01_01_class_02.png[{full-width}]

NOTE: ここでコミットしておきます。

=== 構図のモデルとコードの対応のまとめ

* コードの構造を図で表してみた
** 失われた情報を追加して図やコードを見直した 
* 責務の委譲
** 自分の仕事以外は別のクラスに任せる(委譲)ようになった 
* 情報隠蔽
** 任されたクラスは、仕事の詳細を隠蔽している
* ドメイン分割
** 複数のクラスに分けたしたことで、使うことばが変わった
* 仕様と設計と実装がつながった
** 使用で使っていることばが、実装にも使われている

== 振舞いのモデル図とコードの対応づけ

NOTE: この演習は、個人で実施します。

=== 振舞いに使うモデル図

.振舞いのモデル
* システムやコードの動き方を説明するモデルです。
* 「動的モデル」と呼ぶこともあります。

.振舞いを表すUMLのモデル図
* ステートマシン図（状態遷移図・状態遷移表）
* nシーケンス図
* アクティビティ図
* コミュニケーション図
* など

=== 振舞いのモデルの利用場面

.外側からみた振舞い
* 外側から観測できる振る舞いを描く。
* 外部設計、インターフェース設計用。

.外側からみた振舞い
image::stm_extrnal_use.png[{three-quarters-width}]


.内部の振舞い
* 構成要素がどう振る舞うかを描く。
* 内部設計、実装向け。

.内部の振舞い
image::stm_internal_use.png[{three-quarters-width}]


=== 振舞いのモデルの対応づけ


.振舞いのモデルの対応づけ
* クラスの振舞いを表すステートマシン図に対応づけ。
* 内部の振舞いの方を利用する。

設計で作成するクラス図とステートマシン図を元に、決めたルールに従ってコードを実装するようルールを定めます。
これを「実装方式（変換ルール）」と呼びます。
設計の前にこの対応づけのルールを決めておいて、それから設計するわけです。

.振舞いのモデルの対応づけルール
* ルール０
** クラスの振舞いを担当するメソッドを決めます。
** クラスにそのメソッドがなかったら、追加します。
* ルール１
** ステートマシンの実装に使う繰り返し処理には周期ハンドラを使います。
** `sample01` は使っていません。 `sample02` が使っている例です。
* ルール２
** 設計時するときは、アクションを状態に紐づけておきます（Mooreモデル）。
** 実装時は、switch文を使い、状態１つに１つのcaseを割り当てることにします。
* ルール３
** アクションで使えるのは、そのクラス自身の操作か関連するクラスの操作です。
*** 操作は、メソッドとも呼びます。
*** C言語の場合、この演習の命名規則では `クラス名_操作名` のように、クラス名の接頭詞（プレフィックス）をつけた関数名になります。
** 処理が不足なら、そのクラス自身の操作か関連するクラスに操作を追加して、それを使うことを検討します。
** 関連しないクラスのメソッドを呼び出すことはできません（もちろんメソッドの中で使うこともできません）。それは、新しい関連を引くのと同じ意味になってしまうからです。
*** このようなことが起きてしまう場合、使いたい操作を持つクラスへ関連を追加するか、使いたい操作を持つクラスと使う側のクラスの間に、代わりに呼び出しをする操作を持つクラスを挿入します。
* ルール４
** イベント発生は、アクションの処理中にデバイスや時間の変化をポーリングする方法で実現します。
** この方法では、変化点ではなく、ある時点の値を取得して判断することに注意します。

=== 【準備】

.振舞いのモデルとコードを作成する準備
. 実機（EV3）かhakoniwaの開発環境の `sdk/workspace` で `sample01` を複製して `sample11` を作ります。
** この演習で扱う動作に合わせて、このあと `sample11/app.c` を書き換えます。
. `sample01.asta` を複製して `sample11.asta` を作ります。
** ステートマシン図を追加して、動作の仕様をモデルで表します。

=== 【演習】振舞いのモデルを作成する

構造のモデルを見直した結果できた <<sample01_01_class_02_png>> を元に、別の動作をするプログラムを考え、クラスや操作をどのようにモデル図やコードに半絵すればよいのか考えましょう。

まず、モデル図に振舞いのモデルとしてステートマシン図を追加します。
`sample11` で、 `sample01` から変更したい動作の仕様は、次のようなものです。

.`sample11` 動作の仕様
. 荷物が載ったら前進する
. 壁にぶつかったら止まる
. 荷物が降ろされたら後退する
. 2秒経ったら止まる
. 上記を繰り返す

この仕様に合わせてステートマシン図を書きます。

.クラス `Porter` にステートマシン図を追加する
. 構造ツリーで `Porter` クラスを選択し、右クリックして「図の追加」から「ステートマシン図」を追加します。
. プロパティで、追加した図の名前を「Porterのステートマシン図」とします。

.ステートマシン図を作成する
. 図を編集して、動作の仕様で使っていることばでステートマシン図を作成します。
** 状態名はあとでつけます。
** 「〜が起きたら」を「〜が起きた、なった、経った」と読み替えて、状態遷移のイベントにします。
** 「〜をする」を遷移先の状態のアクションに記載します。
. イベントとアクションが書けたら、状態名をつけます（だいたい次のいずれか）。
** いちばん期待しているイベント（またはそれが起きることを示す業務上のできごと）を使って「〜待ち」とつけます。
** イベントが起きるのを待っている間の処理（またはそれを示す業務上の作業名）を使って「〜中」とつけます。
** 最後の状態は、イベントを待たないし、継続する処理もないので、「完了、終了、到着」といった名前をつけます。

作成したクラス図を `sample11_porter_stm_01.png` として `images` ディレクトリに保存します。

[[sample11_porter_stm_01_png]]
.`Porter` にステートマシン図を追加した
image::sample11_porter_stm_01.png[{full-width}]

NOTE: ここでコミットしておきます。


=== 【演習】振舞いのモデルに合うコードを作成する

作成したステートマシン図に合うような `sample11` のコードを作成しましょう。

まず、状態用の定数、状態変数を用意します（ <<add_states>> ）。

[[add_states]]
.`sample11/app.c`
[example]
--
[source,c,linenums]
----
typedef enum { 
  P_STATE_0, P_STATE_1, P_STATE_2, P_STATE_3 // <1>
} porter_state; // <2>

porter_state p_state = P_STATE_0; // <3>
----
<1> 状態の定数を定義します。この状態名は仮のものです。実際にはみなさんがステートマシン図につけたものと合わせましょう。
<2> 状態名の enum を typedef した型を定義します。
<3> 現在の状態を保持する変数を定義します。
--

次に、状態に対応したswitch文を用意します（ <<add_switch>> ）。
ここでは、 `Porter` クラスの「運搬する ( `transport` ）」という操作を担う関数の中身を作ります。

[[add_switch]]
.`sample11/app.c`
[example]
--
[source,c,linenums]
----
void porter_transport(void) {
switch(p_state) { // <1>
  case P_STATE_0: // <2>
    break;
  case P_STETE_1:
    break;
  case P_STATE_2:
    break;
  case P_STATE_3:
    break;
  default:
    break;
  } 
}
----
<1> ステートマシン図を、状態を場合分けするswitch文として実装します。
<2> このcase文には、みなさんが <<add_states>> で定義した状態名を並べます。
--

作成したswitch文に、アクションとイベントチェックを追加します。
このとき、 <<action_and_transition_01>> のようにステートマシン図からイベントとアクションを参照して作ります。


[[action_and_transition_01]]
.アクションとイベントチェックのステートマシン図とコードの対応関係
image::action_and_transition.png[]


[[action_and_transition_02]]
.アクションとイベントチェックの処理を追加する方法
[example]
--
[source,c,linenums]
----
int P_ENTRY = true; // <1>

void porter_transport(void) {
switch(p_state) {
  case P_STATE_0:
    if( P_ENTRY ) {
      deiver_stop();
      P_ENTRY = false;
    }
    if( carrier_cargo_is_loaded() ) {
      p_state = P_STATE_1;
      P_ENTRY = true;
    }
    break;
    // ...
  case P_STETE_X:
    if( P_ENTRY ) { // <2>
    // entryの処理
    P_ENTRY = false;
    }
    // doの処理
    deiver_forward(); // <3>

    // イベントチェック
    if( イベントを調べる関数の呼び出し() ) { // <4>
      p_state = 遷移先の状態;
      P_ENTRY = true;
    }
    // 他にも待っているイベントがあれば、ここに書く

    if( P_ENTRY ) { // <5>
      // exitの処理
    }
    break;
    // ...
  } 
}
----
<1> entry/do/exitを処理するための各状態の内部状態を覚えておく変数。この変数がtrueなら、直前は状態が変化したタイミング。この変数がfalseなら、すでに現在の状態になったあと。
<2> entry の処理。これは、この状態になった時にだけ実行する。ステートマシン図にentryの処理がなくても、必ず用意して `P_ENTRY=false;` を書いておく。
<3> do の処理。同じ状態にいる間、繰り返し実行する。
<4> イベントチェック。イベントの発生と状態遷移を書く。待っているイベントごとにそのイベントの発生を調べる関数を呼び出すif文を書く。これがtrueなら、次の状態へ遷移するので、状態変数 `p_state` を書き換える。また、ここで `P_ENTRY=true;` としておくのは、この状態から抜けるときには exitの処理を実行させるため。
<5> exitの処理。イベントが発生した時に、この処理を実行してから次の状態へ遷移する。`P_ENTRY` はイベント発生のときにはイベントチェックで true にしているので、このif文がtrueになるのは、いくつかあるイベントのうち少なとも１つが発生した時。
--

sample11/app.cを書き換えると、 <<action_and_transition_03>> に自分が作成したステートマシン図に合わせたコードが表示されます。（書いていないか、ファイル名や場所が異なる場合は、 `Unresolved directive in README.adoc - include::codes/sample11/appc.[]` のような表示になります。


[[action_and_transition_03]]
.`sample11/app.c`
[example]
--
[source,c,linenums]
----
include::{sourcesdir}/sample11/appc.[]
----
--

=== 【準備】タイマーを実験する

「2秒経過した」という動作は、他に何もすることがなければ `sample01` のときのように `tslp_tsk` を使えばできます。
しかし、これはプログラムをスリープさせているので、他の処理もできません。
他の処理を実行しながら時間の経過を待つには、別の方法が必要です。

タイマーは、一定の時間経過を調べるためのしくみとしてよく使われます。
この演習用の簡単なタイマーを用意したので、これを使ってみましょう。

.タイマーを使う準備
. `code` ディレクトリの `sample11` ディレクトリを複製して `sample12`  を作ります。
. タイマーのサンプルとしGoogleDriveのSamplesに `timer01.tar.gz` を用意してあります。これをworkspaceへコピーして、 `tar` コマンドで展開します。
. `unit/timer.h` `unit/timer.c` を `sample12` の中にコピーします。
. `sample11` の `Makefile.inc` を修正します。
** 何箇所かある `APPL_COBJS += util.o` となっているところを、 `APPL_COBJS += util.o timer.o` と変更します。
. `sample11.asta` のクラス図に、タイマークラスを追加します。
. クラス図にタイマークラスを追加します。

.タイマークラス
image::timer.png[{one-quarters-width}]

=== 【演習】タイマーを使うようサンプルを修正する

動作の仕様の「2秒経ったら止まる」ところについて考えてみます、
ここは、2秒間は走行する（ここでは後退するですね）ということですから、走りながら2秒待つことになります。

[NOTE]
--
タイマーで設定した時間が経過したことを「タイマーが発火した」といいます。
期待したイベントが発生しないまま、備えに用意したタイマーが発火することを「タイムアウトした」といいます。
--

そこで、次のように処理を考えます。

.タイマーの起動から発火までの処理
. 時間が経つのを待っている状態のentryで2秒のタイマーを起動します。
. イベントチェックで時間が経過したかどうかを調べます。
. イベントが発生していたら、2秒経ったとみなして次の状態へ遷移します。

図にすると、 <<timer_stm_example>>  のようになります。

[[timer_stm_example]]
.タイマーを使うところのステートマシン図の描き方の例
image::timer2.png[]


これを真似て `sample12` のステートマシン図を書き直してみましょう（ <<sample12_porter_stm_03_png>> ）。

[[sample12_porter_stm_03_png]]
.ステートマシン図を更新した
image::sample12_porter_stm_03.png[{full-width}]


また、`sample12/app.c` をタイマーを使うように修正しましょう（ <<action_and_transition_04>> )。

[[action_and_transition_04]]
.`sample11/app.c`
[example]
--
[source,c,linenums]
----
include::{sourcesdir}/sample12/appc.[]
----
--

[NOTE]
--
ここでコミットしておきます。
--

修正できたら、 `sample12` を動かしてみましょう。




=== 振舞いのモデルとコードの対応のまとめ


* コードの振舞いを図で表してみた
** 失われた情報を追加して図やコードを見直した 
* 責務の委譲
** 自分の仕事以外は別のクラスに任せる(委譲)ようになった 
* 情報隠蔽
** 任されたクラスは、仕事の詳細を隠蔽している
* ドメイン分割
** 複数のクラスに分けたしたことで、使うことばが変わった
* 仕様と設計と実装がつながった
** 使用で使っていることばが、実装にも使われている

